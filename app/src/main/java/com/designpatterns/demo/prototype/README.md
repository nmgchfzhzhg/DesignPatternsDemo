# 原型模式


## 1、定义
     原型模式可以通过一个对象实例确定创建对象的种类，并且通过拷贝创建新的实例
     原型模式实际上就是从一个对象创建另一个新的对象，使新的对象有具有原对象的特征
     原型模式就是在系统clone()标记的基础上，对Clone()进行复写，不同的操作可以产生两种拷贝模式
     原型模式属于创建型模式
     浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝
     深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例
     并且初始化为形式参数实例值
     
## 2、介绍
* 注意
    * 1、深拷贝是通过拷贝内存（包括引用的对象）实现对象的创建，浅拷贝不拷贝引用的对象，但拷贝了引用的值
         如果类的成员属性中都是基本类型，不含对象，也是可以达到深拷贝的效果，深拷贝可以通过将对象序列化成
         字节流及反序列化实现，浅拷贝直接调用clone即可
    * 2、与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的
    * 3、使用原型模式复制对象不会调用类的构造方法，对象的复制通过调用Object类的clone方法来完成的，直接在内存中复制数据
         因此不会调用到类的构造方法，不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中
         只要将构造方法的访问权限设置为private型，就可以实现单例，但是clone方法直接无视构造方法的权限，所以单例模式
         与原型模式是冲突的，使用时特别注意
    * 4、Object类的clone方法只会拷贝对象中的基本数据类型（8种基本数据类型byte、char、short、int、long、
         float、double、booleean），对于数组、容器对象、引用对象等不会拷贝，这就是浅拷贝，如果要实现深拷贝
         必须将原型模式中的数组、容易对象、引用对象等另行拷贝
* 意图
    * 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
* 主要解决
    * 在运行期建立和删除原型
* 何时使用
    * 1、当一个系统应该独立与它的产品创建，构成和表示是
    * 2、当要实例化的类是在运行时刻制定时，例：动态加载
    * 3、避免创建一个与产品类层次平行的工厂类层次时
    * 4、当一个类的实例只能有几个不同状态组合中的一种时，建立相应数据目的的原型并克隆他们可能比每次用合适的状态手工实例化
         该类更方便一些
    * 5、一个类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等
    * 6、通过new产生的一个对象需要非常繁琐的数据准备或者访问权限
    * 7、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时
* 如何解决
    * 利用已有的一个原型对象，快速的生成和原型对象一样的实例
* 关键代码
    * 实现Cloneable接口，java语言Cloneable接口，在运行时通知虚拟机可以安全地实现了此接口的类上使用clone方法
      java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。
    * 重写Object类中的clone方法，Object类中的clone方法，作用是返回对象的一个拷贝，但其作用域是protected类型
      一般的类无法调用，因此，Prototype类需要将clone方法作用域修改为public类型
* 优点
    * 创建新的对象比较复杂是，可以利用原型模式建华对象的创建过程，同时也能够提高效率
    * 可以使用深克隆保持对象的状态
    * 原型模式提供了简化的创建结构
    * 躲避构造函数的约束
* 缺点
    * 在实现克隆的时候可能需要比较复杂的代码
    * 必须实现Cloneable接口
    * 需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难
      但对已有的类进行改造是，不一定是件容易的事，必须修改其源代码，违背了"开闭原则"
* 使用场景
    * 如果创建新对象成本较大，我们可以利用已有的对象进行复制
    * 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式
      来应用，相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好
    * 需要避免使用分层次的工类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象
      得到新实例，可能比使用构造函数创建一个新实例更加方便 
    * 一个对象存在多个修改这的时候使用  
    * 实际项目中，原型模式很少单独出现，一般和工厂模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者
# 3、实现
* [java方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/prototype/java 'java')
* [Kotlin方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/prototype/kotlin 'Kotlin')
* UML类图：

  ![原型模式](https://github.com/nmgchfzhzhg/DesignPatternsDemo/raw/master/app/src/main/java/com/designpatterns/demo/prototype/imgs/原型模式.png) 

## 参考链接
* [RUNOOB.COM](http://www.runoob.com/design-pattern/prototype-pattern.html "菜鸟教程")
* [Java设计模式（五） 原型模式详解](https://blog.csdn.net/u013916933/article/details/51584913 "原型模式")