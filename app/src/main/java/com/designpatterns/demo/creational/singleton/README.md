# 单例模式


## 1、定义
     单例模式属于创建型模式，提供一种创建对象的最佳方式。
     单例模式是确定某一个类只有一个实例，而且自行实例化并想整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
## 2、介绍
* 注意
    * 1、单例类只能有一个实例
    * 2、单例类必须自己创建自己的唯一实例
    * 3、单例类必须给所有其他对象提供这一实例
* 意图
    * 保证一个类仅有一个实例，并提供一个访问它的全局访问点
* 主要解决
    * 一个全局使用的类频繁的创建与销毁（如读取数据库）
* 何时使用
    * 当您想控制实例数目，节省系统资源的时候
* 如何解决
    * 判断系统是否已经有这个单例，如果有则返回，如果没有则创建
* 关键代码
    * 构造函数私有化
* 优点
    * 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例
    * 避免对资源的多重占用（比如读写文件）
* 缺点
    * 获取对象时不能用new
    * 没有接口，不能继承
    * 与单一职责原则冲突
    * 单例对象如果持有Context，那么很容易引发内存泄露
    * 一个类应该关心内部逻辑，而不关心外面怎么样来实例化
* 使用场景
    * 要求生产唯一序列号
    * 一个对象贯穿整个应用程序，并起到全局同意管理控制作用，可以使用单例模式
    * WEB中的计数器，不用每次刷新都在数据库里加一次，用单例模式先缓存起来
    * 创建的一个对象需要消耗的资源过多，比如I/O与数据库的链接等
    * 工具类对象
# 3、实现
* [java方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/creational/singleton/java 'java')
* [Kotlin方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/creational/singleton/kotlin 'Kotlin')
* UML类图：

  ![单例模式](https://github.com/nmgchfzhzhg/DesignPatternsDemo/raw/master/app/src/main/java/com/designpatterns/demo/creational/singleton/imgs/单例模式.png)
* 饿汉式
    * 优点：写法简单，线程安全，没有加锁，执行效率高
    * 缺点：没有懒加载效果，类加载时就初始化，造成内存的浪费
    * 描述：没有实现Lazy初始化，多线程安全，基于classloder机制避免了多线程同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果
* 懒汉式
    * 优点：实现了懒加载效果，第一次调用才初始化
    * 缺点：线程不安全，多线程中不能正常工作
    * 描述：实现Lazy初始化，线程不安全，最基本的实现方式，最大的问题就是不支持多线程，因为没有加锁synchronized，所以在严格意义上并不算是单例模式。在不要去线程安全下可以使用
* 同步锁式
    * 优点：实现了懒加载的效果，第一次调用才初始化，同时也是线程安全
    * 缺点：使用synchronized会造成不必要的同步开销，而且大部分的时候我们是用不到同步
    * 描述：实现Lazy初始化，多线程安全，具备很好的lazy loading，在多线程中很好的工作，但是效率很低，大多数情况下不需要同步
* 双重检测式（DCL double-checked locking）
    * 优点：实现懒加载，多线程安全，效率高
    * 缺点：volatile影响一点性能，高并发下有一定的缺陷，某些情况下DCL会失效
    * 描述：实现Lzay初始化，多线程安全，但要求JDK1.5版本，采用双锁机制，安全并且在多线程情况下保持高性能
* 静态内部类式
    * 优点：实现懒加载，多线程安全，没有性能的缺陷
    * 缺点：
    * 描述：这种方式能达到双重检测式一样的功效，但实现更简单，对静态域使用延迟初始化，这种方式只适用于静态域的情况，双重检测式可在实例域需要延迟初始化的使用。这种方法利用了classloder机会来保证初始化instance时只有一个线程，它跟第饿汉式不同的是，饿汉式只要类被加载，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是类被加载了，instance不一定被装载了，因为内部类没有被主动使用，只有通过显示调用getInstance方法时，才会显示装在内部类，从而实例化instance
* 枚举式
    * 优点：多线程安全，写法相对简单，能防止反序列化重新创建新的对象
    * 缺点：可读性不高，枚举相对静态常量多点内存
    * 描述：没有实现Lazy初始化，多线程安全，实现单例模式的最佳方法，更加简洁，自动支持序列化机制，绝对防止多次实例化
* 容器式
    * 优点：方便管理
    * 缺点：写法负责，相对内存消耗大
    * 描述：这种实现方式使得我们可以管理多种类型的单例，使用时可以通过统一接口进行获取操作，降低用户使用成本，也对用户隐藏了具体实现，降低耦合度
* 实现方法
    * 构造函数不对外开放，一般先私有化，private
    * 通过静态方法返回实例
    * 确保类的实例有且只有一个，特别是在多线程的环境下
    * 尽量确保线程安全   
* 注意事项
    * 使用反射能够破坏单例模式，所以慎用反射
    * 可以通过当第二次调用构造函数时抛出异常来防止反射破坏单例
    * 反序列化时也会破坏单例模式，可以通过重写readResolve的方法避免
    * 如果单例的类实现了cloneable，那么还是很可以拷贝出多个实例
    * 使用多个类加载器加载单例类，也会导致创建多个实例并存的问题
## 参考链接
* [RUNOOB.COM](http://www.runoob.com/design-pattern/singleton-pattern.html "RUNOOB.COM")
* [Android的设计模式-单例模式](https://www.jianshu.com/p/d59c64480ed8 "单例模式")