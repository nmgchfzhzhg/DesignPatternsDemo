# 状态模式


## 1、定义
     状态模式属于行为模式
     状态模式允许通过改变对象的内部状态而改变对象的行为
     状态模式的行为基于他的状态改变
     状态模式的结构跟策略模式的几乎一样，但其本质是不一样的，策略模式中的行为是彼此独立，能够互相替换的，
     而状态模式的行为是平行的，不同状态下起行为也是不一样的，具有不可替换性
     
## 2、介绍
* 注意
    * 1、状态模式适用于当某个对象在他的状态发生改变时，它的行为也随着发生比较大的改变，也就是说在行为受状态结束的情况下可以使用状态模式，而且使用时对象的状态最好不要好过5个
* 意图
    * 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了他的类
* 主要解决
    * 对象的香味依赖于他的状态（属性），并且可以根据它的状态改变而改变它的行为
* 如何解决
    * 将各种具体的状态类抽象出来
    * 一个对象的行为取决一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的对象，这样的对象状态是从事先定义好的
      一系列值中取出的，当一个这样的对象与外部事件产生互动时，其内部状态就会发生改变，从而使得系统的行为也随之发生改变
* 关键代码
    * Context：封装的对象，环境的角色
    * LiftState：接口或者抽象类，封装了Context的特定状态相关的行为
    * OpenningState、ClosingState、RunningState、StoppingState：接口实现类或者子类，实现了一个与Context某个相关状态的相关行为
* 优点
    * 封装了转换规则
    * 每个状态都是一个子类，易于扩展和维护
    * 避免过多的条件语句，使得结构更清晰，提高代码的可维护性
    * 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
* 缺点
    * 状态模式的使用会增加系统类和对象的个数
    * 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱
    * 状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新的状态，而且修改某个状态类的行为也需修改对应类的源代码
* 使用场景
    * 对象的行为取决于其状态，随着状态改变时其行为也许改变，例如权限设计，人员状态不同即使执行相同的行为结果也会不同
    * 包含大量的与状态相关的条件判断语句时
# 3、实现
* [java方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/behavioral/state/java 'java')
* [Kotlin方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/behavioral/state/kotlin 'Kotlin')
* UML类图：

  ![状态模式](https://github.com/nmgchfzhzhg/DesignPatternsDemo/raw/master/app/src/main/java/com/designpatterns/demo/behavioral/state/imgs/状态模式.png) 
* 注意事项
    * 状态和行为
      所谓状态的对象，通常指的就是对象实例的属性的值，而行为指的就是对象的功能，在具体点说，行为大多可以对应到方法上
      状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能，就是说，状态和行为是相关联的，他们的关系可以描述为状态决定行为
      由于状态实在运行期被改变的，因此行为也会在运行期根据状态的改变而改变
    * 行为的平行性
      注意平行线而不是平等性，所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的那一条，行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的
      而平等性强调的是课替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理
      状态模式和策略模式的结构相似，但是它们的目的、实现、本质却是完全不一样的，还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的
    * 环境和状态处理对象
      在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理
      在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类
      客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象
## 参考链接
* [RUNOOB.COM](http://www.runoob.com/design-pattern/state-pattern.html "RUNOOB.COM")
* [Java设计模式——状态模式（STATE PATTERN）](https://blog.csdn.net/u012401711/article/details/52675873 "状态模式")
* [策略模式的孪生兄弟——对状态模式的深度复习总结](https://www.cnblogs.com/kubixuesheng/p/5180509.html "策略模式的孪生兄弟——对状态模式的深度复习总结")
