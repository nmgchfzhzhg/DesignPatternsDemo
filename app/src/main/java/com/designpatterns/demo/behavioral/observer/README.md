# 观察者模式


## 1、定义
     观察者模式属于行为模式
     观察者模式又被称作发布/订阅（Publish/Subscribe）模式、模型/视图（Model/View）模式、源/监听器（Source/Listener）模式或从属者（Dependents）模式
     观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时，所依赖于他的对象都得到通知并被自动更新
     
## 2、介绍
* 注意
    * 1、针对观察者与被观察者分别定义接口，有利于分别进行扩展
    * 2、重点就子啊被观察者的实现中：
      * 定义观察者集合，并定义针对集合的添加、删除操作，用于增加、删除订阅者（观察者）
      * 定义通知方法，用于将新情况通知给观察者用户（订阅者用户）
    * 3、观察者中需要有个接收被观察者通知的方法
* 意图
    * 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并被自动更新
* 主要解决
    * 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作
    * 观察者模式主要用来解耦，将被观察者和观察者解耦，让他们之间没有依赖或者依赖关系很小
* 如何解决
    * 使用面向对象技术，将这种依赖关系弱化
* 关键代码
    * Observer(抽象观察者)：为所有的具体观察者定义一个接口，在得到主题通知时更新自己
    * Boy、Girl(具体的观察者)：实现抽象观察者定义的更新接口，当得到主题更改通知时更新自身的状态
    * Observable(抽象主题)：又叫抽象观察者，把所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象
    * Postman(具体主题)：又叫具体被观察者，将有关状态存入具体观察者对象，在具体主题内部状态改变时，给所有登记过的观察者发出通知
* 优点
    * 解除观察者与被观察者之间的耦合，让耦合的双方都依赖于抽象，而不是依赖具体，从而使得各自的变化都不会影响另一边的变化
    * 抑郁扩展，对同一主题新增观察者时无需修改原有代码
* 缺点
    * 依赖关系并未完全解除，抽象主题让然依赖抽象观察者
    * 使用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者，多个观察者，开发、调试等内容会比较复杂，而且在java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整天的执行效率，在这种情况下，一般会采用异步实现
    * 可能会引起多余的数据通知
* 使用场景
    * 当一个对象的改变需要通知其他对象改变时，而且他不知道具体有多少个对象有待改变时
    * 当一个对象必须通知其他对象，而他又不能假定其他对象是谁
    * 跨系统的消息交换场景，如消息队列，时间总线的处理机制
# 3、实现
* [java方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/behavioral/observer/java 'java')
* [Kotlin方式实现](https://github.com/nmgchfzhzhg/DesignPatternsDemo/tree/master/app/src/main/java/com/designpatterns/demo/behavioral/observer/kotlin 'Kotlin')
* UML类图：

  ![观察者模式](https://github.com/nmgchfzhzhg/DesignPatternsDemo/raw/master/app/src/main/java/com/designpatterns/demo/behavioral/observer/imgs/观察者模式.png) 
* 注意事项
    * 推模型
      主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据
    * 拉模型
      主题对象在同桌观察者的时候，只传递少量信息，如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从肢体对象中拉数据，一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取
    * 两种模式的比较
      * 推模型是假定主题对象知道观察者需要的数据，而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值
      * 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况，这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者，而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以使用各种情况的需要
## 参考链接
* [RUNOOB.COM](http://www.runoob.com/design-pattern/observer-pattern.html "RUNOOB.COM")
* [Android的设计模式-观察者模式](https://www.jianshu.com/p/8f32da74cd8b "观察者模式")
* [JAVA与模式》之观察者模式](http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html "JAVA与模式》之观察者模式")
